### TO_FLOAT
## Converts the pdxvar "to_float_input" to a bitwise array 
## The below function has 2 parameters: to_float_input and temp_array_id
## These parameters will be cleared(by resetting to 0) after the function execution
## TO_FLOAT_INPUT
# The variable to be converted into bitwise format
# If no input is given, the function will use 0 in place **and return no error**
## ARRAY_ID
# the array_id identifies which temp array is to be used, in the format "temp_array_[?id]"
# If no array_id is assigned, the function will use temp_array_0 in place
# If the array_id is not an integer, then the function will display an error
## Errors consist of a temp error var (io_error_flag) and a message in log corresponding to the error
## This function does not implement infinity or NaN cases, since pdxvars do not reach those situations(subnormals however, are included with 0)
to_float = {
    set_temp_variable = { whole_check = temp_array_id }
    round_temp_variable = whole_check
    if = {
        limit = {
            NOT = { check_variable = { whole_check = temp_array_id } }
        }

        add_to_temp_variable = { io_error_flag = 1 }
        log="to_float array_id error, temp_array_id = [?temp_array_id]"
    }
    
    clear_temp_array = temp_array_@var:temp_array_id
    clear_temp_array = temp_mantissa_array
    set_temp_variable = { temp_exp = 21 }
    set_temp_variable = { actual_exp = -127 }
    set_temp_variable = { negative_flag = 0 }
    if = { # Special hard-coded case for min_num because sign flip
        limit = {
            check_variable = { to_float_input = -2147483.648 }
        }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
        add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
    }
    else = {
        # Set sign bit
        if = {
            limit = {
                check_variable = { to_float_input < 0 }
            }
            add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
            multiply_temp_variable = { to_float_input = -1 }
        }
        else = {
            add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
        }

        set_temp_variable = { bit_compare = 2097152 }
        while_loop_effect = {
            limit = {
                NOT = { check_variable = { bit_compare < 1 } }
            }
        
            if = {
                limit = {
                    NOT = { check_variable = { to_float_input < bit_compare } }
                }

                subtract_from_temp_variable = { to_float_input = bit_compare }
                add_to_temp_array = { temp_mantissa_array = 1 }
                if = {
                    limit = {
                        check_variable = { actual_exp = -127 }
                    }
                    set_temp_variable = { actual_exp = temp_exp }
                }
            }
            else = {
                if = {
                    limit = {
                        NOT = { check_variable = { actual_exp = -127 } }
                    }
                    add_to_temp_array = { temp_mantissa_array = 0 }
                }
            }
            subtract_from_temp_variable = { temp_exp = 1 }
            divide_temp_variable = { bit_compare = 2 }
        }
        while_loop_effect = {
            limit = {
                AND = {
                    check_variable = { temp_mantissa_array^num < 24 }
                    NOT = { check_variable = { to_float_input = 0 } }
                }
            }

            multiply_temp_variable = { to_float_input = 2 }
            if = {
                limit = {
                    NOT = { check_variable = { to_float_input < 1 } }
                }

                subtract_from_temp_variable = { to_float_input = 1 }
                add_to_temp_array = { temp_mantissa_array = 1 }
                if = {
                    limit = {
                        check_variable = { actual_exp = -127 }
                    }
                    set_temp_variable = { actual_exp = temp_exp }
                }
            }
            else = {
                if = {
                    limit = {
                        NOT = { check_variable = { actual_exp = -127 } }
                    }
                    add_to_temp_array = { temp_mantissa_array = 0 }
                }
            }
            subtract_from_temp_variable = { temp_exp = 1 }
        }

        # round mantissa
        if = {
            limit = {
                OR = {
                    check_variable = { to_float_input > 0.5 }
                    AND = {
                        check_variable = { to_float_input = 0.5 }
                        check_variable = { temp_mantissa_array^23 = 1 }
                    }
                }
            }

            # add and carry addition upwards
            add_to_temp_variable = { temp_mantissa_array^23 = 1 }
            for_loop_effect = {
                start = 23
                end = 0
                compare = greater_than
                add = -1
                value = idx

                if = {
                    limit = {
                        check_variable = { temp_mantissa_array^idx = 2 }
                    }
                    if = {
                        limit = {
                            check_variable = { idx = 0 }
                        }
                        add_to_temp_variable = { actual_exp = 1 }
                    }
                    else = {
                        set_temp_variable = { temp_index = idx }
                        subtract_from_temp_variable = { temp_index = 1 }
                        add_to_temp_variable = { temp_mantissa_array^temp_index = 1 }
                    }
                    set_temp_variable = { temp_mantissa_array^idx = 0 }
                }
            }
        }
        # Trim leading zero(if exists) and pad mantissa to 23 bits
        if = {
            limit = {
                check_variable = { temp_mantissa_array^num > 0 }
            }
            remove_from_temp_array = {
                array = temp_mantissa_array
                index = 0
            }
        }
        resize_temp_array = { temp_mantissa_array = 23 }

        add_to_temp_variable = { actual_exp = 127 } # add exponent bias
        set_temp_variable = { bit_compare = 128 }
        for_loop_effect = {
            start = 0
            end = 8
            if = {
                limit = {
                    NOT = { check_variable = { actual_exp < bit_compare } }
                }
                add_to_temp_array = { temp_array_@var:temp_array_id = 1 }
                subtract_from_temp_variable = { actual_exp = bit_compare }
            }
            else = {
                add_to_temp_array = { temp_array_@var:temp_array_id = 0 }
            }
            divide_temp_variable = { bit_compare = 2 }
        }
        for_each_loop = {
            array = temp_mantissa_array
            value = v

            add_to_temp_array = { temp_array_@var:temp_array_id = v }
        }
    }

    set_temp_variable = { to_float_input = 0 }
    set_temp_variable = { temp_array_id = 0 }
}
### TO_PDXVAR
## Reads a bit array in floating-point format and outputs the closest pdxvar to_pdxvar_output
## The below function has 1 parameter: temp_array_id
## This parameter will be cleared(by resetting to 0) after the function execution
## ARRAY_ID
# the array_id identifies which temp array is to be used, in the format "temp_array_[?id]"
# If no array_id is assigned, the function will use temp_array_0 in place
# If the array_id is not an integer, then the function will display an error
# If the array is not 32 elements long, then the function will display an error
# If the array has elements which are not 0 or 1, then the function will display an error
## TO_PDXVAR_OUTPUT
# The output variable which holds the converted value
# Do not confuse this with the store_bitwise function, as the two functions will output different values from the same bitarray
# If the value is too high to fit in a pdxvar(greater than 2148483.647 or less than 2147483.648), then a temp var(to_pdxvar_overflow_flag) will be set to 1 or -1 depending on whether the float was too high or too low respectively, a warning will be logged, and the pdxvar will default to 0 
# In addition, two temp vars exist to notify the user of an infinity or NaN(to_pdxvar_inf_flag and to_pdxvar_nan_flag respectively) and the output will default to 0. Similarly, +1 or -1 will denote a positive or negative special value 
## Errors consist of a temp error var (io_error_flag) and a message in log corresponding to the error
## Additionally, any error will not trigger the to_digit_array function, and instead return 0 to the output variable
to_pdxvar = {
    if = {
        limit = {
            to_pdxvar_trigger = yes
        }
    }
}
### TO_DIGIT_ARRAY
## Reads a bit array in floating-point format and outputs two things: The array of digits(digit_array_output) and the power of 10(digit_power_output), akin to scientific format
## The below function has 1 parameter: temp_array_id
## This parameter will be cleared(by resetting to 0) after the function execution
## ARRAY_ID
# the array_id identifies which temp array is to be used, in the format "temp_array_[?id]"
# If no array_id is assigned, the function will use temp_array_0 in place
# If the array_id is not an integer, then the function will display an error
# If the array is not 32 elements long, then the function will display an error
# If the array has elements which are not 0 or 1, then the function will display an error
## DIGIT_ARRAY_OUTPUT
# This array contains the digits of the floating-point number stored one digit per element
# For example, the decimal number 125 would be stored:
# [1, 2, 5]
## DIGIT_POWER_OUTPUT
# The power gives the power of 10 the floating-point number
# For example, the decimal number 625 would have a power of 2
## Errors consist of a temp error var (io_error_flag) and a message in log corresponding to the error
## SPECIAL CASES
# Infinity - Some cases cannot be converted to a number as usual. Therefore, a temp var is set to signify the special case: to_pdxvar_inf_flag
# NaN - Some cases cannot be converted to a number as usual. Therefore, a temp var is set to signify the special case: to_pdxvar_nan_flag
# In both cases, no error is returned and both the power and array remain zeroed out and empty respectively
to_digit_array = {
    if = {
        limit = {
            to_digit_array_trigger = yes
        }
    }
}