# ieeeNextUp_trigger
### Returns the next highest floating point value to the argument
### The below function has 1 parameter: arg_a
### +inf cannot be incremented, nor can NaNs
### -inf is incremented to the largest magnitude negative float
### Both zeroes increment to the lowest positive float
## ARGUMENTS
### arg_a: The float to be incremented
ieeeNextUp_trigger = {
    if = {
        limit = {
            check_variable = { arg_a = -2147483.648 }
        }
        set_temp_variable = { arg_a = 0.001 }
    }
    else_if = {
        limit = {
            NOT = { check_variable = { arg_a > -8388.608 } }
        }
        subtract_from_temp_variable = { arg_a = 0.001 }
    }
    else_if = {
        limit = {
            NOT = { check_variable = { arg_a < 0 } }
            check_variable = { arg_a < 2139095.040 }
        }
        add_to_temp_variable = { arg_a = 0.001 }
    }
}
# ieeeNextDown_trigger
### Returns the next lowest floating point value to the argument
### The below function has 1 parameter: arg_a
### -inf cannot be decremented, nor can NaNs
### +inf is decremented to the largest positive float
### Both zeroes decrement to the smallest magnitude negative float
## ARGUMENTS
### arg_a: The float to be decremented
ieeeNextDown_trigger = {
    if = {
        limit = {
            check_variable = { arg_a < 0 }
        }
        add_to_temp_variable = { arg_a = 2147483.648 }
    }
    else = {
        subtract_from_temp_variable = { arg_a = 2147483.648 }
    }
    ieeeNextUp_trigger = yes
    if = {
        limit = {
            check_variable = { out_a < 0 }
        }
        add_to_temp_variable = { out_a = 2147483.648 }
    }
    else = {
        subtract_from_temp_variable = { out_a = 2147483.648 }
    }
}
# ieeeScaleB_trigger
### Returns float arg_a scaled by 2^arg_b, if arg_b is an integer
### The below function has 2 parameters: arg_a and arg_b
### Zeroes, infinities, and NaNs cannot be scaled
## ARGUMENTS
### arg_a: The float to be incremented
### arg_b: The integer pdxvar to scale the float by
ieeeScaleB_trigger = {
    set_temp_variable = { out_a = arg_a }
    set_temp_variable = { round_check = arg_b }
    if = {
        limit = {
            ieee_isZero = no
            ieee_isFinite = yes
            check_variable = { round_check = arg_b }
        }

        set_temp_variable = { out_a = 0 }

        set_temp_variable = { to_bitwise_input = arg_a }
        set_temp_variable = { temp_array_id = 1000 }
        to_bitwise_trigger = yes

        set_temp_variable = { exp_a = -127 }
        set_temp_variable = { exponent_inc = 128 }
        all_of = {
            array = temp_array_1000
            index = idx

            if = {
                limit = {
                    NOT = { check_variable = { idx < 1 } }
                    check_variable = { idx < 9 }
                }
                
                if = {
                    limit = {
                        check_variable = { temp_array_1000^idx = 1 }
                    }
                    add_to_temp_variable = { exp_a = exponent_inc }
                }
                divide_temp_variable = { exponent_inc = 2 }
            }
        }

        populate_mantissas = yes
        if = {
            limit = {
                check_variable = { exp_a < -149 }
            }
            set_temp_variable = { out_a = 0 }
        }
        else = {
            add_to_temp_variable = { exp_a = arg_b }

            # Set rounding in case of subnormal
            set_temp_variable = { mantissa_compare_index = 150 }
            add_to_temp_variable = { mantissa_compare_index = exp_o }
            set_temp_variable = { mantissa_compare = temp_mantissa_o^mantissa_compare_index }
            subtract_from_temp_variable = { mantissa_compare = 1 }

            all_of = {
                array = temp_mantissa_o
                index = idx

                if = {
                    limit = {
                        check_variable = { idx > mantissa_compare_index }
                        check_variable = { temp_mantissa_o^idx = 1 }
                        check_variable = { mantissa_compare = 0 }
                    }
                    set_temp_variable = { mantissa_compare = 1 }
                }
            }
            all_of = {
                array = temp_mantissa_a
                value = v

                add_to_temp_array = { temp_mantissa_o = v }
            }

            round_and_convert_output = yes
        }
    }
}
# ieeeLogB_trigger
### Returns the exponent of arg_a
### The below function has 1 parameter: arg_a
### Zeroes increment the error flag `op_error_flag` and return -2147483.648
### NaNs increment the error flag `op_error_flag` and return 200
### Infinities return the maximal 2147483.647
## ARGUMENTS
### arg_a: The float to have the exponent taken
ieeeLogB_trigger = {
    if = {
        limit = {
            ieee_isZero = yes
        }
        set_temp_variable = { out_a = -2147483.648 }
        add_to_temp_variable = { op_error_flag = 1 }
        log = "zero argument for ieeeLogB"
    }
    else_if = {
        limit = {
            ieee_isInfinite = yes
        }
        set_temp_variable = { out_a = 2147483.647 }
    }
    else_if = {
        limit = {
            ieee_isnan = yes
        }
        set_temp_variable = { out_a = 200 }
        add_to_temp_variable = { op_error_flag = 1 }
        log = "NaN argument [?arg_a] for ieeeLogB"
    }
    else_if = {
        limit = {
            ieee_isFinite = yes
        }

        set_temp_variable = { out_a = 0 }

        set_temp_variable = { to_bitwise_input = arg_a }
        set_temp_variable = { temp_array_id = 1000 }
        to_bitwise_trigger = yes

        set_temp_variable = { exp_a = -127 }
        set_temp_variable = { exponent_inc = 128 }
        all_of = {
            array = temp_array_1000
            index = idx

            if = {
                limit = {
                    NOT = { check_variable = { idx < 1 } }
                    check_variable = { idx < 9 }
                }
                
                if = {
                    limit = {
                        check_variable = { temp_array_1000^idx = 1 }
                    }
                    add_to_temp_variable = { exp_a = exponent_inc }
                }
                divide_temp_variable = { exponent_inc = 2 }
            }
        }
        populate_mantissas = yes
        set_temp_variable = { out_a = exp_a }
    }
}
# ieeeNegate_trigger
### Negates arg_a
### The below function has 1 parameter: arg_a
## ARGUMENTS
### arg_a: The float to be negated
ieeeNegate_trigger = {
    set_temp_variable = { out_a = arg_a }
    if = {
        limit = {
            check_variable = { out_a < 0 }
        }
        add_to_temp_variable = { out_a = 2147483.648 }
    }
    else = {
        subtract_from_temp_variable = { out_a = 2147483.648 }
    }
}
# ieeeAbs_trigger
### Returns abs(arg_a)
### The below function has 1 parameter: arg_a
## ARGUMENTS
### arg_a: The float to take the absolute value of
ieeeAbs_trigger = {
    if = {
        limit = {
            check_variable = { out_a < 0 }
        }
        add_to_temp_variable = { out_a = 2147483.648 }
    }
}
# ieeeCopySign_trigger
### Takes the sign bit of arg_b and sets arg_a to be the same
### The below function has 2 parameters: arg_a and arg_b
## ARGUMENTS
### arg_a: The float to set the sign bit
### arg_b: The float to take the sign bit of
ieeeCopySign_trigger = {
    set_temp_variable = { out_a = arg_a }
    if = {
        limit = {
            check_variable = { arg_b < 0 }
        }
        add_to_temp_variable = { out_a = 2147483.648 }
    }
    else = {
        subtract_from_temp_variable = { out_a = 2147483.648 }
    }
}
# ieeeClass_trigger
### Returns a code based on the type of the float
### 1: quietNaN
### 2: negativeInfinity
### 3: negativeNormal
### 4: negativeSubnormal
### 5: negativeZero
### 6: positiveZero
### 7: positiveSubnormal
### 8: positiveNormal
### 9: positiveInfinity
### The below function has 1 parameter: arg_a
## ARGUMENTS
### arg_a: The float to take the class of
ieeeClass_trigger = {
    set_temp_variable = { out_a = 0 }
    if = {
        limit = {
            ieee_isnan = yes
        }
        set_temp_variable = { out_a = 1 }
    }
    else_if = {
        limit = {
            check_variable = { arg_a = -8388.608 }
        }
        set_temp_variable = { out_a = 2 }
    }
    else_if = {
        limit = {
            NOT = { check_variable = { arg_a < -2139095.040 } }
            check_variable = { arg_a < -8388.608 }
        }
        set_temp_variable = { out_a = 3 }
    }
    else_if = {
        limit = {
            check_variable = { arg_a > -2147483.648 }
            check_variable = { arg_a < -2139095.040 }
        }
        set_temp_variable = { out_a = 4 }
    }
    else_if = {
        limit = {
            check_variable = { arg_a = -2147483.648 }
        }
        set_temp_variable = { out_a = 5 }
    }
    else_if = {
        limit = {
            set_temp_variable = { arg_a = 0 }
        }
        set_temp_variable = { out_a = 6 }
    }
    else_if = {
        limit = {
            check_variable = { arg_a > 0 }
            check_variable = { arg_a < 8388.608 }
        }
        set_temp_variable = { out_a = 7 }
    }
    else_if = {
        limit = {
            NOT = { check_variable = { arg_a < 8388.608 } }
            check_variable = { arg_a < 2139095.040 }
        }
        set_temp_variable = { out_a = 8 }
    }
    else_if = {
        limit = {
            check_variable = { arg_a = 2139095.040 }
        }
        set_temp_variable = { out_a = 9 }
    }

    # Fallback just in case
    if = {
        limit = {
            check_variable = { out_a = 0 }
        }
        log = "ieeeClass error: [?arg_a]"
    }
}
